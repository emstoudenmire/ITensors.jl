
# Main Steps Left To Do

X remove Jordan-Wigner strings from AutoMPO

X have productMPS and similar functions put
  QN-carrying Link indices so that fermionic
  MPS always consist of bosonic ITensors on
  all or at most one site

- Fix issue where hopping Hamiltonian for
  Electron sites giving non-Hermitian 
  result in AutoMPO

- dim=1 'tag' Index for fermion-odd MPS?

- replace `has_fermion_string` system used by 
  AutoMPO with logic that computes ITensors of
  all operators passed to AutoMPO before making
  the MPO, then stores a Dict or similar of what
  parity these operators have

- provide a helper system for users to convert
  fermionic operators to bosonic operators

# Oct 2020 Fermions Revisit

- branch is "new_fermions" for
  both ITensors.jl and NDTensors.jl

- let's work with the emstoudenmire/ITensors.jl
  and emstoudenmire/NDTensors.jl forks

- fermion related changes should be marked 
  with a comment:
  # <fermions>


## Important Functions & Changes in NDTensors:

- blocksparse/blocksparsetensor.jl:
  + contract function: extra information about blocks
    extracted and passed to `compute_alpha` function
    which computes minus sign factor for lower-level contraction
  + default `compute_alpha` defined which always returns 1, but
    is overloaded in ITensors.jl (physics/fermions.jl) when
    the indsT1 and indsT2 arguments are of QNIndexSet type
  + Base.permutedims! of BlockSparseTensor calls permfactor
    (which is defaulted to 1 in NDTensors) on the inds of
    the input tensor and includes the resulting factor 
    in the block-level/dense permutedims!
    --> this is important for permuting & adding ITensors!

## Important Functions & Changes in ITensors:

- itensor.jl:
  + ITensor getindex and setindex!
    calls to `permfactor`
  + ITensor dag
    - call `scale_blocks!` with permutation as
      if indices reversed then permuted back
    - call `scale_blocks!` with function
      `internal_factor` which puts in an extra
      minus for any QN values with a mod 4 that
      is 2 or 3

## Conceptual Logic of Various Functions

+ compute_alpha (physics/fermions.jl):
  here the logic is that various permutations are
  computed, thinking of a 'hypothetical' ordering
  of the indices of the contracted tensors, and 
  the resulting tensor afterward, even if the actual
  contraction code does a different ordering of the
  input tensors. The signs of each permutation is 
  computed and combined into the final result sign.
  The permutation `permR` is the one that takes the
  'hypothetical' final index order and maps it to
  the actual one that NDTensors selects for the result
  tensor. Finally, the value `alpha_arrows` corrects
  the sign for any cases where a contracted ket is 
  to the left of a contracted bra (i.e. any of the 
  contracted inds of T1 has an Out arrow)




#######################################
# Older Fermion Notes
#######################################

## Possible Bugs

- is new permutedims!! in blocksparsetensor.jl
  defined fermionically?

- does dag permute indices?

- implement fermionic indices for diagblocksparse.jl too

## Roadmap

X isfermionic for IndexVal
X Start with setting elements, so
  we can construct
X Next permutation of ITensors
  --> TEST: operators [done]
  --> TEST: multi-site wavefunctions
X Work on addition next (no combined indices)
  --> TEST: operators [done]
  --> TEST: multi-site wavefunctions [done]
- dag / conj of ITensors
- Work on contraction (no combined indices)
  --> TEST: multi-site wavefunction inner product
  --> TEST: C and Cdag acting on wavefunctions
- Handle combined indices
  (perhaps ignore parity-mod-4 issue for now and just
   use particle number mod 2 for parity, mod 4 for ratio?
   would have to only combine indices with same arrows though?)
- Tools for mapping on-paper C,Cdag operators to
  equivalent bosonic ITensors (using Grassman numbers or vectors)
  Maybe put Grassman numbers *inside* QNIndex, similar to combining
  indices and updating ratio & parity

## Possible improvements (once things are working)

- more streamlined handling of fermionic ITensors in
  dag function (removing need for has_fermionic_sectors function)

## General Comments & Ideas

- Define `isfermionic` for QN? How? See below:

- What if a QN has more than one fermionic QNVal,
  such as:
  q = QN(("Na",1,-1),("Nb",0,-1))
  Is it still fermionic? What is the parity and ratio?
  Maybe yes fermionic, and parity is combined parity.

## Contraction Notes

`compute_contraction_labels` is used to produce labels
(integer arrays) indicating common and unique indices
and their ordering, then the Tensors `contract` function
is called. Negative integers in the labels arrays mean
contracted indices, though it is optional and the
important thing is just matching versus unique.

When calling the Tensors `contract` function, the
type passed is:
Tensor{Float64,2,BlockSparse{Float64,Array{Float64,1},2},IndexSet{2}}

`contract` for BlockSparse storage is defined in
Tensors/blocksparse/blocksparsetensor.jl (line 556)

Ideas to generalize:
- The "inds" in the lower level block sparse routines are actually IndexSet,
  so information about QNs is available
- Create a default function defined by Tensors like `compute_alpha` which
  computes alpha in: R = alpha*(T1*T2) + beta*R
  (see line 574 of Tensors/blocksparse/blocksparsetensor.jl)
  By default this function just returns 1.0, then have the upper ITensor
  level override this function when the arguments are IndexSet
